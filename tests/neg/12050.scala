class P[X, Y]

type Swap[X] = X match
  case P[x, y] => Swap[P[y, x]]

val z: P[String, Int] = ??? : Swap[P[Int, String]] // error
//                            ^
// Recursion limit exceeded.
// Maybe there is an illegal cyclic reference?
// If that's not the case, you could also try to increase the stacksize using the -Xss JVM option.
// A recurring operation is (inner to outer):
//
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   ...
//
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
//   normalizing P[String, Int] match ...
//   normalizing P[Int, String] match ...
