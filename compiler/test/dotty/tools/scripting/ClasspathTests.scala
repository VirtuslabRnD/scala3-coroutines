package dotty
package tools
package scripting

import java.io.File
import java.nio.file.{Files, Paths, Path}

import org.junit.Test

import vulpix.TestConfiguration

import scala.sys.process._
import scala.jdk.CollectionConverters._
import dotty.tools.dotc.config.Properties._

/** Runs all tests contained in `compiler/test-resources/scripting/` */
class ClasspathTests:
  val packBinDir = "dist/target/pack/bin"
  val scalaCopy = makeTestableScriptCopy("scala")
  val scalacCopy = makeTestableScriptCopy("scalac")
  val commonCopy = makeTestableScriptCopy("common")

  // only interested in classpath test scripts
  def testFiles = scripts("/scripting").filter { _.getName.matches("classpath.*[.]sc") }
  val testScriptName = "classpathReport.sc"
  def testScript = testFiles.find { _.getName == testScriptName } match
    case None => sys.error(s"test script not found: ${testScriptName}")
    case Some(file) => file

  def getScriptPath(scriptName: String): Path = Paths.get(s"$packBinDir/$scriptName")

  def exists(scriptPath: Path): Boolean = Files.exists(scriptPath)
  def packBinScalaExists:Boolean = exists(Paths.get(s"$packBinDir/scala"))

  // create edited copy of [dist/bin/scala] and [dist/bin/scalac] for scalacEchoTest
  def makeTestableScriptCopy(scriptName: String): Path =
    val scriptPath: Path = getScriptPath(scriptName)
    val scriptCopy: Path = getScriptPath(s"$scriptName-copy")
    if Files.exists(scriptPath) then
      val lines = Files.readAllLines(scriptPath).asScala.map {
        _.replaceAll("/scalac", "/scalac-copy").
        replaceAll("/common", "/common-copy").
        replaceFirst("^ *eval(.*JAVACMD.*)", "echo $1")
      }
      val bytes = (lines.mkString("\n")+"\n").getBytes
      Files.write(scriptCopy, bytes)

    scriptCopy

  /*
   * verify java command line generated by scalac.
   */
  @Test def scalacEchoTest =
    val relpath = testScript.toPath.relpath.norm
    printf("===> scalacEchoTest for script [%s]\n", relpath)
    printf("bash is [%s]\n", bashExe)

    if packBinScalaExists then
      val echoTest = "" // "SCALAC_ECHO_TEST=1"
      val bashCmdline = s"SCALA_OPTS= $echoTest ${scalaCopy.norm} -classpath '$wildcardEntry' $relpath"
     
      // ask [dist/bin/scalac] to echo generated command line so we can verify some things
      val cmd = Array(bashExe, "-c", bashCmdline)

      //cmd.foreach { printf("[%s]\n", _) }

      val javaCommandLine = exec(cmd:_*).mkString(" ").split(" ").filter { _.trim.nonEmpty }
      printf("\n==================== isWin[%s], cygwin[%s], mingw[%s], msys[%s]\n", isWin, cygwin, mingw, msys)
      javaCommandLine.foreach { printf("java-command[%s]\n", _) }

      val output = scala.collection.mutable.Queue(javaCommandLine:_*)
      output.dequeueWhile( _ != "dotty.tools.scripting.Main")

      def consumeNext = if output.isEmpty then "" else output.dequeue()

      // assert that we found "dotty.tools.scripting.Main"
      val str = consumeNext
      if str != "dotty.tools.scripting.Main" then
        
      assert(str == "dotty.tools.scripting.Main", s"found [$str]")
      val mainArgs = output.copyToArray(Array.ofDim[String](output.length))

      // display command line starting with "dotty.tools.scripting.Main"
      output.foreach { line =>
        printf("%s\n", line)
      }

      // expecting -classpath next
      assert(consumeNext.replaceAll("'", "") == "-classpath")
      
      // 2nd arg to scripting.Main is 'lib/*', with semicolon added if Windows jdk
    
      // PR #10761: verify that [dist/bin/scala] -classpath processing adds $psep to wildcard if Windows
      val classpathValue = consumeNext
      printf("classpath value [%s]\n", classpathValue)
      assert( !winshell || classpathValue.contains(psep) )
    
      // expecting -script next
      assert(consumeNext.replaceAll("'", "") == "-script")

      // PR #10761: verify that Windows jdk did not expand single wildcard classpath to multiple file paths
      if javaCommandLine.last != relpath then
        printf("last: %s\nrelp: %s\n", javaCommandLine.last, relpath)
        assert(javaCommandLine.last == relpath, s"unexpected output passed to scripting.Main")

  /*
   * verify classpath reported by called script.
   */
  @Test def hashbangClasspathVerifyTest =
    val relpath = testScript.toPath.relpath.norm
    printf("===> hashbangClasspathVerifyTest for script [%s]\n", relpath)
    printf("bash is [%s]\n", bashExe)

    if false && packBinScalaExists then
      val bashCmdline = s"SCALA_OPTS= $relpath"
      val cmd = Array(bashExe, "-c", bashCmdline)

      cmd.foreach { printf("[%s]\n", _) }

      // test script reports the classpath it sees 
      val scriptOutput = exec(cmd:_*)
      val scriptCwd = findTaggedLine("cwd", scriptOutput)
      printf("script ran in directory [%s]\n", scriptCwd)
      val scriptCp = findTaggedLine("classpath", scriptOutput)

      val hashbangClasspathJars = scriptCp.split(psep).map { _.getName }.sorted.distinct
      val packlibJars = listJars(s"$scriptCwd/dist/target/pack/lib").sorted.distinct
     
      // verify that the classpath set in the hashbang line is effective
      if hashbangClasspathJars.size != packlibJars.size then
        printf("%d test script jars in classpath\n", hashbangClasspathJars.size)
        printf("%d jar files in dist/target/pack/lib\n", packlibJars.size)

      assert(hashbangClasspathJars.size == packlibJars.size)


//////////////// end of tests ////////////////
lazy val cwd = Paths.get(".").toAbsolutePath
lazy val wildcardEntry = "dist/target/pack/lib/*"

def listJars(dir: String) =
  val packlibDir = Paths.get(dir).toFile
  if packlibDir.isDirectory then
    packlibDir.listFiles.toList.map { _.getName }.filter { _.endsWith(".jar") }
  else
    Nil

import scala.jdk.CollectionConverters._
lazy val env:Map[String, String] = System.getenv.asScala.toMap

// script output expected as "<tag>: <value>"
def findTaggedLine(tag: String, lines: Seq[String]): String =
  lines.find { _.startsWith(tag) } match
    case None => sys.error(s"no $tag: found in script output")
    case Some(cwd) => cwd.dropWhile( _ != ' ').trim // discard tag

def exec(cmd: String *): Seq[String] = Process(cmd).lazyLines_!.toList

def which(str:String) =
  var out = ""
  path.find { entry =>
    val it = Paths.get(entry).toAbsolutePath
    it.toFile.isDirectory && {
      var testpath = s"$it/$str".norm
      val test = Paths.get(testpath)
      if test.toFile.exists then
        out = testpath
        true
      else
        val test = Paths.get(s"$it/$str.exe".norm)
        if test.toFile.exists then
          out = testpath
          true
        else
          false
      }
    }

  out

def bashExe = which("bash")
def unameExe = which("uname")
def path = envOrElse("PATH", "").split(psep).toList
def psep = sys.props("path.separator")

def cygwin = ostype == "cygwin"
def mingw = ostype == "mingw"
def msys = ostype == "msys"
def winshell = cygwin || mingw || msys

def ostypeFull = if unameExe.nonEmpty then exec(unameExe).mkString else ""
def ostype = ostypeFull.toLowerCase.takeWhile{ cc => cc >= 'a' && cc <='z' || cc >= 'A' && cc <= 'Z' }

extension(p:Path)
  def relpath: Path = cwd.relativize(p)
  def norm: String = p.toString.replace('\\', '/')

extension(path: String)
  def getName: String = norm.replaceAll(".*/", "")

  // Normalize path separator, convert relative path to absolute
  def norm: String =
    path.replace('\\', '/') match {
      case s if s.secondChar == ":" => s // .drop(2) // path without drive letter
      case s if s.startsWith("./") => s.drop(2)
      case s => s
    }

  def parent: String = norm.replaceAll("/[^/]*$", "")

  // convert to absolute path relative to cwd.
  def absPath: String = norm match
    case str if str.isAbsolute => norm
    case _ => Paths.get(userDir, norm).toString.norm

  def isDir: Boolean = Files.isDirectory(Paths.get(path))

  def toUrl: String = Paths.get(absPath).toUri.toURL.toString

  // Treat norm paths with a leading '/' as absolute.
  // Windows java.io.File#isAbsolute treats them as relative.
  def isAbsolute = path.norm.startsWith("/") || (isWin && path.secondChar == ":")
  def secondChar: String = path.take(2).drop(1).mkString("")

extension (str: String) def dropExtension =
  str.reverse.dropWhile(_ != '.').drop(1).reverse

//extension(f: File) def absPath =
//f.getAbsolutePath.replace('\\', '/')

